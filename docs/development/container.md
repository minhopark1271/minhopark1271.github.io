---
title: 컨테이너
parent: 개발
nav_order: 30
description: "컨테이너, Docker, Kubernetes 핵심 개념 정리. 네임스페이스, cgroups, 레이어 파일시스템부터 Pod, Service, Ingress까지 인프라 레벨 완벽 가이드."
---

# 컨테이너
{:.no_toc}

쿠버네티스, 도커, 컨테이너의 핵심 개념을 인프라 레벨에서 정리한다.

## 목차
{:.no_toc}

1. TOC
{:toc}

---

## 컨테이너(Container): "가벼운 VM"이 아니라 "프로세스 격리"

컨테이너는 VM처럼 OS를 하나 더 띄우는 게 아니라, 리눅스에서 **프로세스(들)**를 "격리된 환경"에서 실행하는 방식이다.

### 핵심 기술(인프라 레벨)

| 기술 | 역할 | 상세 |
|------|------|------|
| **Namespaces** | 프로세스가 보는 "세상"을 분리 | PID, NET, MNT, UTS, IPC, USER 등 |
| **cgroups** | 자원 제한/측정 | CPU/메모리/IO/프로세스 수 제한 및 사용량 측정 |
| **레이어 파일시스템** | 이미지 레이어 관리 | overlayfs 등으로 쓰기 레이어만 추가, 저장공간 효율적 |

> **요약**: 컨테이너 = 격리된 프로세스 실행 + 자원관리 + 레이어 파일시스템

---

## 도커(Docker): 컨테이너를 "쓰기 쉽게 만든" 툴체인

도커는 컨테이너를 **빌드/패키징/배포/실행**까지 한 번에 다루게 해주는 제품/생태계다.

### 도커가 인프라에서 하는 일

- **이미지 빌드**: Dockerfile → 레이어 이미지 생성
- **레지스트리 연동**: 이미지 저장/배포 (Docker Hub, 사설 레지스트리 등)
- **컨테이너 실행 관리**: 포트 매핑, 볼륨 마운트, 환경변수, 로그 드라이버 등

### 런타임 관점

요즘 쿠버네티스/클러스터 환경에서는 OCI 표준 기반으로 **containerd**, **CRI-O** 같은 런타임도 흔히 사용한다. 도커는 로컬 개발/툴링 경험 측면에서 여전히 강력하다.

### 빌드(Build) vs 패키징(Packaging)

실무에서는 Dockerfile 한 장에서 같이 처리되기 때문에 섞여 쓰이기도 하지만, 관점(목적)이 다르다.

**빌드(Build)** = 이미지를 **생성**하는 과정 (조리 과정)
- 초점: 만드는 행위 자체
- 주로 하는 일:
  - 의존성 설치: `pip install`, `apt-get install`, `npm ci`
  - 소스 컴파일/번들링: `gcc`, `mvn package`, `npm run build`
  - Dockerfile 명령(`RUN`, `COPY` 등) 실행 → 레이어 생성
- 결과: 로컬/CI에 이미지(artifact) 생성

**패키징(Packaging)** = 배포/운영 가능한 형태로 **제품화** (포장/정리)
- 초점: 무엇을 포함/제외하고 어떤 정책으로 배포할지 결정
- 주로 결정하는 것:
  - 포함/제외 범위: 소스 포함 여부, 디버그 툴 포함 여부
  - 빌드 도구/캐시 제거: 최종 이미지는 "실행에 필요한 것만"
  - 엔트리포인트/CMD, 기본 환경변수, 헬스체크
  - 보안/권한: non-root 실행, 파일 권한, capability 제한
  - 태그/버전 전략: `1.2.3`, git sha, `latest` 정책
- 결과: 운영에 올려도 되는 배포 단위로 정리된 이미지

| 비유 | 설명 |
|------|------|
| **빌드** | 요리 (만들기) |
| **패키징** | 포장 (유통/운영에 적합하게 정리) |

**실무 사례**:
- 빌드는 됐는데 패키징이 나쁜 경우: 빌드 도구/캐시가 이미지에 남아 용량 폭증, 취약점 증가
- 패키징이 좋은 경우: 멀티스테이지 빌드로 "빌드 스테이지"와 "런타임 스테이지" 분리 → 최종 이미지는 실행 파일/필수 라이브러리만 남겨 작고 안전

### 런타임(Runtime)의 두 가지 의미

런타임은 문맥에 따라 층위가 다르다. 공통점은 "실행 중에 필요하거나 실행을 가능하게 하는 것"이다.

**언어 런타임(Language Runtime)**: 애플리케이션 코드를 실행해주는 실행 환경(엔진)

| 런타임 | 구성 |
|--------|------|
| **Python** | 인터프리터 + 표준 라이브러리 + OS 라이브러리 |
| **JVM** | 바이트코드 실행 VM + GC/JIT + 표준 라이브러리 |
| **Node** | V8 엔진 + 이벤트 루프 + 표준 라이브러리 |

- 하는 일: 코드 실행(인터프리트/JIT), 메모리 관리(GC), 파일/네트워크/스레드 등 OS 기능 추상화
- "이미지에 파이썬 런타임 포함" = python 실행기와 필요한 라이브러리가 이미지 안에 있어야 함

**컨테이너 런타임(Container Runtime)**: 컨테이너(격리된 프로세스)를 실제로 만들어 실행/관리하는 실행 환경

| 런타임 | 수준 |
|--------|------|
| **containerd, CRI-O** | 고수준 |
| **runc** | 저수준 OCI 런타임 |

- 하는 일: 이미지 pull/저장, 루트 파일시스템 준비, namespaces/cgroups 설정, 마운트/네트워크 설정, 프로세스 라이프사이클 관리

> **정리**: 언어 런타임은 "내 앱 코드를 실행", 컨테이너 런타임은 "그 앱을 담은 컨테이너 프로세스를 격리해 실행"

### build time vs run time

**run + time** = 프로그램이 실행(run)하는 시간/기간(time) 동안 필요한 것

| 시점 | 설명 |
|------|------|
| **build time** | 코드를 만들고 준비하는 시점 (컴파일/패키징/이미지 생성) |
| **run time** | 프로그램이 실제로 실행 중인 시점 |

"런타임 에러"도 여기서 유래:
- 컴파일 타임 에러: 빌드/컴파일 단계에서 잡힘
- 런타임 에러: 실행 중에 발생 (예외/크래시)

---

## 쿠버네티스(Kubernetes): "컨테이너 운영을 자동화"하는 클러스터 OS

쿠버네티스는 여러 대 서버(노드)에서 컨테이너를 **자동 배치/확장/복구/업데이트**하는 오케스트레이션 시스템이다.

### 쿠버네티스가 해결하는 인프라 문제

| 문제 | 해결 방식 |
|------|-----------|
| **스케줄링** | 어디 노드에 띄울지 결정 |
| **확장** | 트래픽 증가 시 자동/수동 스케일 |
| **복구** | 컨테이너/노드 장애 시 재기동/재배치 |
| **배포** | 롤링 업데이트, 롤백 |
| **서비스 디스커버리** | 변하는 Pod IP를 숨기고 안정적 접근 제공 |

---

## 쿠버네티스 내부 구조(인프라 레벨)

### Control Plane(관리 plane): "두뇌"

| 컴포넌트 | 역할 |
|----------|------|
| **API Server** | 모든 요청의 관문 (쿠버네티스의 프론트도어) |
| **etcd** | 클러스터 상태 저장 (분산 Key-Value) — "진실의 원장" |
| **Scheduler** | 새 Pod를 어느 노드에 올릴지 결정 |
| **Controller Manager** | desired state와 current state를 맞추는 컨트롤 루프 |

### Worker Node(실행 plane): "근육"

| 컴포넌트 | 역할 |
|----------|------|
| **kubelet** | 노드 에이전트. Pod 실행/상태 관리 |
| **Container Runtime** | 실제 컨테이너 실행 (containerd/CRI-O 등) |
| **CNI 플러그인** | Pod 네트워크 구성 |
| **kube-proxy** | 서비스 트래픽 라우팅/로드밸런싱 (또는 eBPF 기반 대체) |

### 실행 단위: Pod

**Pod**는 스케줄링의 최소 단위다.

- 컨테이너 1개 또는 여러 개(sidecar) 포함 가능
- Pod 내부 컨테이너들은 보통 **네트워크 네임스페이스 공유** (같은 IP/포트 공간)

---

## 네트워크 관점(CNI, Service, Ingress)

### Pod 네트워킹 기본 철학

- 각 Pod는 클러스터 내부에서 **고유 IP**를 가진다
- Pod 간 통신을 "원래 라우팅 가능"하게 만드는 게 목표

이를 구현하는 표준 인터페이스가 **CNI(Container Network Interface)**다.

### Service

Pod는 죽고 살아나며 IP가 바뀌므로, 고정 접근점이 필요하다.

**Service = 고정된 가상 IP + 로드밸런싱**

| 타입 | 용도 |
|------|------|
| **ClusterIP** | 클러스터 내부용 |
| **NodePort** | 외부 노출 (노드 포트로) |
| **LoadBalancer** | 외부 노출 (클라우드 LB 연동) |

### Ingress / Gateway

- HTTP(S) 레벨에서 호스트/경로 기반 라우팅
- Ingress Controller(NGINX/Traefik 등) 또는 Gateway API 구현체로 처리

---

## 스토리지 관점(PV/PVC, CSI, 영속성)

컨테이너 파일시스템은 기본적으로 **휘발성**이므로, 데이터는 외부 스토리지에 붙여야 한다.

| 개념 | 설명 |
|------|------|
| **PV/PVC** | "필요한 스토리지"를 선언/바인딩 |
| **CSI** | Container Storage Interface - 스토리지 플러그인 표준 |

CSI를 통해 클라우드 디스크(EBS/PD), NFS, Ceph 등과 연동 가능하다.

---

## 보안 관점(격리/권한/정책)

컨테이너는 VM과 달리 **호스트 커널을 공유**하므로 커널 공격면을 염두에 둬야 한다.

| 보안 요소 | 설명 |
|-----------|------|
| **RBAC** | 누가 어떤 리소스/API에 접근 가능한지 |
| **Pod Security** | root 금지, capability 제한, readOnly FS 등 |
| **NetworkPolicy** | Pod 간 통신 허용/차단 (네트워크 방화벽 개념) |
| **Secrets** | 민감정보 관리 (권한 최소화, 외부 KMS 연동 등) |

---

## 운영 관점: 쿠버네티스가 "인프라 레벨"에서 강력한 이유

1. **선언형(desired state)**으로 "이 상태를 유지해"라고 정의하면
2. **컨트롤 루프**가 지속적으로 감시/조정해서
3. **장애/스케일/배포**를 자동화한다

운영 단위가 "서버 1대"에서 "클러스터 자원 풀"로 바뀐다.

---

## 한 줄 요약

| 개념 | 정의 |
|------|------|
| **컨테이너** | 커널 기능으로 격리된 프로세스 실행 방식 |
| **도커** | 컨테이너를 이미지로 패키징하고 쉽게 실행/배포하는 툴체인 |
| **쿠버네티스** | 여러 서버에서 컨테이너를 자동 운영(배치/확장/복구/업데이트)하는 플랫폼 |
| **빌드** | 이미지를 "만드는 과정" |
| **패키징** | 이미지를 "배포/운영 가능하게 제품화(정리/정책 결정)" |
| **언어 런타임** | 앱 코드를 실행하는 엔진/환경 (Python/JVM/Node) |
| **컨테이너 런타임** | 컨테이너 프로세스를 격리해 실행/관리 (containerd/CRI-O/runc) |
| **run + time** | "실행되는 동안" 필요한 것 |
