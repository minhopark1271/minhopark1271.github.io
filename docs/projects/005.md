---
nav_order: 100
parent: 프로젝트
title: '[BACKLOG] 005 - Backtesting Framework Integration'
description: "트레이딩 모델 백테스팅 프레임워크. 거래 비용, 슬리피지, 포지션 사이징 반영. Walk-forward 검증. Sharpe, MDD 평가."
---

# 005 - Backtesting Framework Integration
{:.no_toc}

## 목차
{:.no_toc}

1. TOC
{:toc}

---

| 상태 | 생성일 | 수정일 |
|------|--------|--------|
| backlog | 2025-12-18 | - |

---

## Summary

모델 예측 결과를 실제 거래 시뮬레이션으로 검증하는 **백테스팅 프레임워크**를 구축한다. 거래 비용, 슬리피지, 포지션 사이징, 최대 포지션 제한 등 실전 요소 반영.

## Background

### Problem Statement
- 현재 평가: 분류 정확도, 회귀 MAE 등 ML 지표 위주
- 실제 거래 성과와 ML 지표 간 괴리 발생 가능
- 거래 비용, 연속 거래 제한, 자금 관리 등 미반영

### Target State
- 실제 거래 시뮬레이션 (Paper Trading)
- 거래 비용, 슬리피지 반영
- 포지션 관리 (사이징, 최대 보유 기간)
- Walk-forward 검증

## Implementation Plan

### Phase 1: Core Backtester

```python
@dataclass
class Trade:
    entry_time: pd.Timestamp
    exit_time: pd.Timestamp
    direction: str  # 'LONG' or 'SHORT'
    entry_price: float
    exit_price: float
    size: float
    pnl: float
    pnl_pct: float
    exit_reason: str  # 'TP', 'SL', 'TIMEOUT', 'SIGNAL'

class Backtester:
    def __init__(self, config: dict):
        self.config = config
        self.initial_capital = config.get('initial_capital', 10000)
        self.trading_cost = config.get('trading_cost', 0.001)  # 0.1%
        self.slippage = config.get('slippage', 0.0005)  # 0.05%
        self.max_position_pct = config.get('max_position_pct', 0.1)  # 10%
        self.max_holding_periods = config.get('max_holding_periods', 24)  # 6시간

        self.trades: list[Trade] = []
        self.equity_curve: list[float] = []
        self.current_position = None

    def run(self, predictions: pd.DataFrame, prices: pd.DataFrame) -> dict:
        """
        백테스트 실행

        predictions: gate_prob, action_pred, pnl_q50 등
        prices: OHLCV 데이터
        """
        capital = self.initial_capital
        self.equity_curve = [capital]

        for i, (ts, pred) in enumerate(predictions.iterrows()):
            price_data = prices.loc[ts]

            # 1. 현재 포지션 관리
            if self.current_position:
                capital, closed = self._manage_position(
                    self.current_position, price_data, capital
                )
                if closed:
                    self.current_position = None

            # 2. 새 신호 처리
            if self.current_position is None:
                signal = self._generate_signal(pred)
                if signal:
                    self.current_position = self._open_position(
                        signal, price_data, capital
                    )

            self.equity_curve.append(capital)

        return self._compute_results()
```

### Phase 2: Position Management

```python
def _manage_position(self, position: dict, price_data: dict,
                     capital: float) -> tuple[float, bool]:
    """
    포지션 관리: TP/SL 체크, 타임아웃, 청산
    """
    current_price = price_data['close']
    high = price_data['high']
    low = price_data['low']

    # PnL 계산
    if position['direction'] == 'LONG':
        unrealized_pnl = (current_price / position['entry_price'] - 1)
        worst_price = low
        best_price = high
    else:
        unrealized_pnl = (1 - current_price / position['entry_price'])
        worst_price = high
        best_price = low

    # Stop Loss 체크
    if position['direction'] == 'LONG':
        sl_hit = low <= position['stop_loss']
    else:
        sl_hit = high >= position['stop_loss']

    if sl_hit:
        return self._close_position(position, position['stop_loss'],
                                    capital, 'SL')

    # Take Profit 체크
    if position['direction'] == 'LONG':
        tp_hit = high >= position['take_profit']
    else:
        tp_hit = low <= position['take_profit']

    if tp_hit:
        return self._close_position(position, position['take_profit'],
                                    capital, 'TP')

    # Timeout 체크
    position['holding_periods'] += 1
    if position['holding_periods'] >= self.max_holding_periods:
        return self._close_position(position, current_price,
                                    capital, 'TIMEOUT')

    return capital, False

def _close_position(self, position: dict, exit_price: float,
                    capital: float, reason: str) -> tuple[float, bool]:
    """
    포지션 청산
    """
    # 슬리피지 적용
    if position['direction'] == 'LONG':
        actual_exit = exit_price * (1 - self.slippage)
        pnl_pct = (actual_exit / position['entry_price'] - 1)
    else:
        actual_exit = exit_price * (1 + self.slippage)
        pnl_pct = (1 - actual_exit / position['entry_price'])

    # 거래 비용
    pnl_pct -= self.trading_cost

    pnl = position['size'] * pnl_pct
    new_capital = capital + pnl

    trade = Trade(
        entry_time=position['entry_time'],
        exit_time=pd.Timestamp.now(),
        direction=position['direction'],
        entry_price=position['entry_price'],
        exit_price=actual_exit,
        size=position['size'],
        pnl=pnl,
        pnl_pct=pnl_pct,
        exit_reason=reason
    )
    self.trades.append(trade)

    return new_capital, True
```

### Phase 3: Signal Generation

```python
def _generate_signal(self, pred: pd.Series) -> dict | None:
    """
    모델 예측을 거래 신호로 변환
    """
    gate_prob = pred['gate_prob']
    action = pred['action_pred']  # 0=NO_TRADE, 1=LONG, 2=SHORT

    if gate_prob < self.config.get('gate_threshold', 0.5):
        return None

    if action == 0:  # NO_TRADE
        return None

    direction = 'LONG' if action == 1 else 'SHORT'

    # Quantile 기반 TP/SL 설정 (004 구현 후)
    if 'pnl_q90' in pred and 'pnl_q10' in pred:
        take_profit_pct = pred['pnl_q90'] / 100
        stop_loss_pct = max(pred['pnl_q10'] / 100, -self.config['max_loss_pct'])
    else:
        # 고정 TP/SL
        take_profit_pct = self.config.get('default_tp', 0.01)
        stop_loss_pct = self.config.get('default_sl', -0.005)

    return {
        'direction': direction,
        'take_profit_pct': take_profit_pct,
        'stop_loss_pct': stop_loss_pct,
        'confidence': gate_prob
    }
```

### Phase 4: Results Computation

```python
def _compute_results(self) -> dict:
    """
    백테스트 결과 계산
    """
    if not self.trades:
        return {'error': 'No trades executed'}

    pnls = [t.pnl_pct for t in self.trades]
    equity = np.array(self.equity_curve)

    # Basic metrics
    total_trades = len(self.trades)
    winning_trades = sum(1 for t in self.trades if t.pnl > 0)
    win_rate = winning_trades / total_trades

    # Returns
    total_return = (equity[-1] / equity[0] - 1) * 100
    avg_return = np.mean(pnls) * 100
    std_return = np.std(pnls) * 100

    # Risk metrics
    sharpe = (np.mean(pnls) / np.std(pnls)) * np.sqrt(252 * 4) if np.std(pnls) > 0 else 0

    # Drawdown
    running_max = np.maximum.accumulate(equity)
    drawdown = (running_max - equity) / running_max
    max_drawdown = np.max(drawdown) * 100

    # Profit factor
    gross_profit = sum(t.pnl for t in self.trades if t.pnl > 0)
    gross_loss = abs(sum(t.pnl for t in self.trades if t.pnl < 0))
    profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')

    # Exit analysis
    exit_reasons = {}
    for t in self.trades:
        exit_reasons[t.exit_reason] = exit_reasons.get(t.exit_reason, 0) + 1

    return {
        'total_trades': total_trades,
        'win_rate': win_rate,
        'total_return_pct': total_return,
        'avg_return_pct': avg_return,
        'std_return_pct': std_return,
        'sharpe_ratio': sharpe,
        'max_drawdown_pct': max_drawdown,
        'profit_factor': profit_factor,
        'exit_reasons': exit_reasons,
        'trades': self.trades,
        'equity_curve': self.equity_curve
    }
```

### Phase 5: Walk-Forward Validation

```python
class WalkForwardValidator:
    """
    Walk-forward 검증: 과거 데이터로 학습, 미래 데이터로 테스트 반복
    """
    def __init__(self, train_periods: int = 90, test_periods: int = 30,
                 step_periods: int = 30):
        self.train_periods = train_periods  # 학습 기간 (일)
        self.test_periods = test_periods    # 테스트 기간 (일)
        self.step_periods = step_periods    # 이동 간격 (일)

    def run(self, data: pd.DataFrame, model_handler: ModelHandler) -> list[dict]:
        """
        Walk-forward 실행
        """
        results = []
        dates = data['ts'].dt.date.unique()

        for start_idx in range(0, len(dates) - self.train_periods - self.test_periods,
                               self.step_periods):
            train_start = dates[start_idx]
            train_end = dates[start_idx + self.train_periods]
            test_start = train_end
            test_end = dates[start_idx + self.train_periods + self.test_periods]

            # Train
            model_handler.run_training(str(train_start), str(train_end))

            # Test
            predictions = model_handler.run_batch_inference(str(test_start), str(test_end))

            # Backtest
            backtester = Backtester(self.config)
            test_prices = data[(data['ts'] >= test_start) & (data['ts'] < test_end)]
            result = backtester.run(predictions, test_prices)

            result['period'] = {'train': (train_start, train_end),
                                'test': (test_start, test_end)}
            results.append(result)

        return results
```

## Configuration

```python
BACKTEST_CONFIG = {
    'initial_capital': 10000,
    'trading_cost': 0.001,      # 0.1% (maker+taker 평균)
    'slippage': 0.0005,         # 0.05%
    'max_position_pct': 0.1,    # 최대 10% 포지션
    'max_holding_periods': 24,  # 최대 6시간 보유
    'gate_threshold': 0.5,
    'default_tp': 0.01,         # 1% TP
    'default_sl': -0.005,       # 0.5% SL
    'max_loss_pct': 0.02,       # 최대 2% 손실
}
```

## Success Criteria

- [ ] Backtest Sharpe > 1.0
- [ ] Win rate > 50%
- [ ] Profit factor > 1.5
- [ ] Max drawdown < 15%
- [ ] Walk-forward 결과 일관성 (CV < 30%)

## Files to Create/Modify

- `src/prediction/backtester.py` (신규)
- `src/prediction/walk_forward.py` (신규)
- `src/prediction/prediction_model.py` - backtest 연동
- `scripts/run_backtest.py` (신규)

## Dependencies

- [003-1-selective-trading-gate-action](003-1-selective-trading-gate-action.md) - Gate+Action 구조
- [004-quantile-pnl-output-metrics](004-quantile-pnl-output-metrics.md) - Quantile 기반 TP/SL
- 가격 데이터 (OHLCV)

## Estimated Scope

- Backtester core: ~200 lines
- Position management: ~100 lines
- Walk-forward: ~80 lines
- Integration: ~50 lines
- **Total: ~430 lines**

## References

- Zipline, Backtrader 등 기존 백테스팅 프레임워크
- "Advances in Financial Machine Learning" (M. López de Prado)

## Related Tickets

- [003-1-selective-trading-gate-action](003-1-selective-trading-gate-action.md) - Gate+Action 신호 생성
- [004-quantile-pnl-output-metrics](004-quantile-pnl-output-metrics.md) - Quantile 기반 TP/SL
- [007-regime-detection-adaptive](007-regime-detection-adaptive.md) - 레짐별 백테스트 분석

