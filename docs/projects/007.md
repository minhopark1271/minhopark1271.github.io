---
nav_order: 110
parent: 프로젝트
title: '[BACKLOG] 007 - Regime Detection and Adaptive Thresholds'
description: "시장 레짐 감지 및 적응형 임계치. 변동성/추세/횡보 분류. 레짐별 Gate 임계치 자동 조정. 레짐 조건부 예측."
---

# 007 - Regime Detection and Adaptive Thresholds
{:.no_toc}

## 목차
{:.no_toc}

1. TOC
{:toc}

---

| 상태 | 생성일 | 수정일 |
|------|--------|--------|
| backlog | 2025-12-18 | - |

---

## Summary

시장 레짐(Regime)을 감지하고 **레짐별 적응형 임계치** 및 **레짐 조건부 예측**을 구현한다. 변동성, 추세, 횡보 등 시장 상태에 따라 다른 전략 적용.

## Background

### Problem Statement
- 동일한 Gate/Action 임계치가 모든 시장 상태에서 최적이 아님
- 고변동성 장세: 넓은 스톱로스, 높은 임계치 필요
- 저변동성 횡보: 좁은 스톱로스, 낮은 임계치로 빈번한 거래 가능
- 추세장 vs 횡보장에서 최적 전략이 다름

### Target State
- 레짐 분류: TRENDING_UP, TRENDING_DOWN, RANGING, HIGH_VOL
- 레짐별 Gate/Action 임계치 자동 조정
- 레짐 조건부 예측 헤드 (선택적)

## Implementation Plan

### Phase 1: Regime Feature Engineering

```python
def compute_regime_features(df: pd.DataFrame, lookback: int = 20) -> pd.DataFrame:
    """
    레짐 감지를 위한 피처 계산
    """
    close = df['btc_binance_close']

    # 1. Volatility regime
    returns = close.pct_change()
    volatility = returns.rolling(lookback).std() * np.sqrt(96 * 365)  # 연환산
    vol_percentile = volatility.rank(pct=True)  # 0-1 정규화

    # 2. Trend regime (ADX 기반 또는 단순 방향성)
    sma_fast = close.rolling(10).mean()
    sma_slow = close.rolling(30).mean()
    trend_strength = (sma_fast - sma_slow) / close  # 추세 강도

    # 3. Mean reversion indicator
    bb_mid = close.rolling(20).mean()
    bb_std = close.rolling(20).std()
    bb_position = (close - bb_mid) / (2 * bb_std)  # -1 ~ 1

    # 4. Regime classification
    df['regime_vol'] = pd.cut(vol_percentile,
                              bins=[0, 0.3, 0.7, 1.0],
                              labels=['LOW_VOL', 'NORMAL_VOL', 'HIGH_VOL'])

    df['regime_trend'] = np.where(
        trend_strength > 0.01, 'TRENDING_UP',
        np.where(trend_strength < -0.01, 'TRENDING_DOWN', 'RANGING')
    )

    return df
```

### Phase 2: Regime-aware Thresholds

```python
REGIME_THRESHOLDS = {
    'HIGH_VOL': {
        'gate_threshold': 0.7,      # 높은 확신 필요
        'edge_threshold': 0.5,      # 높은 기대 수익 필요
        'risk_limit': -1.0,         # 넓은 스톱로스
        'position_size': 0.5,       # 작은 포지션
    },
    'NORMAL_VOL': {
        'gate_threshold': 0.5,
        'edge_threshold': 0.3,
        'risk_limit': -0.5,
        'position_size': 1.0,
    },
    'LOW_VOL': {
        'gate_threshold': 0.4,      # 낮은 확신으로도 거래
        'edge_threshold': 0.2,      # 작은 엣지도 수용
        'risk_limit': -0.3,         # 좁은 스톱로스
        'position_size': 1.5,       # 큰 포지션
    },
    'TRENDING_UP': {
        'long_bias': 1.2,           # Long 선호
        'short_bias': 0.8,
    },
    'TRENDING_DOWN': {
        'long_bias': 0.8,
        'short_bias': 1.2,          # Short 선호
    },
    'RANGING': {
        'long_bias': 1.0,
        'short_bias': 1.0,
        'mean_reversion': True,     # 볼린저 밴드 전략 활성화
    }
}

def get_adaptive_threshold(regime_vol: str, regime_trend: str) -> dict:
    """
    현재 레짐에 맞는 임계치 반환
    """
    vol_config = REGIME_THRESHOLDS.get(regime_vol, REGIME_THRESHOLDS['NORMAL_VOL'])
    trend_config = REGIME_THRESHOLDS.get(regime_trend, REGIME_THRESHOLDS['RANGING'])

    return {**vol_config, **trend_config}
```

### Phase 3: Regime-conditional Model Head (선택적)

```python
def create_regime_aware_model(base_features: int, num_regimes: int = 4):
    """
    레짐 조건부 예측 헤드
    각 레짐에 특화된 출력 생성
    """
    base_input = Input(shape=(BASE_TIME_WINDOW, base_features))
    regime_input = Input(shape=(num_regimes,), name='regime_input')  # one-hot

    # Shared LSTM
    lstm_out = LSTM(LSTM_UNITS)(base_input)

    # Regime embedding
    regime_embed = Dense(32, activation='relu')(regime_input)

    # Regime-conditioned prediction
    combined = concatenate([lstm_out, regime_embed])
    hidden = Dense(LSTM_UNITS, activation='relu')(combined)

    # Outputs
    gate = Dense(1, activation='sigmoid', name='gate')(hidden)
    action = Dense(3, activation='softmax', name='action')(hidden)

    return Model(inputs=[base_input, regime_input], outputs=[gate, action])
```

### Phase 4: Online Regime Detection

```python
class RegimeDetector:
    """
    실시간 레짐 감지 및 전환 신호
    """
    def __init__(self, vol_lookback: int = 20, trend_lookback: int = 30):
        self.vol_lookback = vol_lookback
        self.trend_lookback = trend_lookback
        self.current_regime = None
        self.regime_history = []

    def update(self, new_price: float, new_volume: float) -> dict:
        """
        새 데이터로 레짐 업데이트
        """
        # ... 계산 로직 ...

        new_regime = {
            'volatility': self._classify_volatility(),
            'trend': self._classify_trend(),
            'confidence': self._regime_confidence(),
            'transition_signal': self._detect_transition()
        }

        self.current_regime = new_regime
        self.regime_history.append(new_regime)

        return new_regime

    def _detect_transition(self) -> bool:
        """
        레짐 전환 감지 (급격한 변화)
        """
        if len(self.regime_history) < 2:
            return False

        prev = self.regime_history[-2]
        curr = self.regime_history[-1]

        return (prev['volatility'] != curr['volatility'] or
                prev['trend'] != curr['trend'])
```

### Phase 5: Regime-based Evaluation

```python
def evaluate_by_regime(predictions: dict, actuals: dict, regimes: list) -> dict:
    """
    레짐별 성과 분석
    """
    results = {}

    for regime in ['HIGH_VOL', 'NORMAL_VOL', 'LOW_VOL',
                   'TRENDING_UP', 'TRENDING_DOWN', 'RANGING']:
        mask = [r == regime for r in regimes]

        if sum(mask) == 0:
            continue

        regime_preds = predictions[mask]
        regime_actuals = actuals[mask]

        results[regime] = {
            'count': sum(mask),
            'gate_precision': precision_score(regime_actuals['gate'], regime_preds['gate']),
            'avg_pnl': np.mean(regime_actuals['pnl'][regime_preds['gate'] > 0.5]),
            'sharpe': calculate_sharpe(regime_actuals['pnl'][regime_preds['gate'] > 0.5]),
        }

    return results
```

## Configuration

```python
# Regime detection
VOL_LOOKBACK = 20  # 변동성 계산 기간
TREND_LOOKBACK = 30  # 추세 계산 기간

# Volatility thresholds (연환산 기준)
VOL_LOW = 0.3   # 30% 이하: 저변동성
VOL_HIGH = 0.7  # 70% 이상: 고변동성

# Trend thresholds
TREND_THRESHOLD = 0.01  # 1% 이상 괴리: 추세
```

## Success Criteria

- [ ] 레짐별 성과 차이 통계적 유의 (p < 0.05)
- [ ] HIGH_VOL 레짐에서 MDD 감소: -20%
- [ ] LOW_VOL 레짐에서 거래 횟수 증가: +30%
- [ ] 전체 Sharpe 개선: +0.2

## Files to Modify

- `src/prediction/prediction_model.py`
  - Regime feature 추가
  - Adaptive threshold 로직
- `src/prediction/regime_detector.py` (신규)
- `src/api/routes/predictions.py`
  - 레짐 정보 API 제공

## Dependencies

- [003-1-selective-trading-gate-action](003-1-selective-trading-gate-action.md) - Gate+Action 구조
- [004-quantile-pnl-output-metrics](004-quantile-pnl-output-metrics.md) - PnL 평가 지표
- [006-advanced-loss-functions](006-advanced-loss-functions.md) - 선택적

## Estimated Scope

- Regime features: ~80 lines
- Adaptive thresholds: ~60 lines
- Regime detector class: ~100 lines
- Evaluation: ~50 lines
- **Total: ~290 lines**

## References

- Hamilton, "Regime Switching Models"
- 기존 indicators (ATR, RSI 등) 활용

## Related Tickets

- [003-1-selective-trading-gate-action](003-1-selective-trading-gate-action.md) - Gate/Action 임계치 적용 대상
- [004-quantile-pnl-output-metrics](004-quantile-pnl-output-metrics.md) - 레짐별 리스크 설정
- [005-backtesting-framework](005-backtesting-framework.md) - 레짐별 백테스트 분석
- [008-model-ensemble-uncertainty](008-model-ensemble-uncertainty.md) - 레짐별 불확실성 다를 수 있음

