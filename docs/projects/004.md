---
nav_order: 40
parent: 프로젝트
title: '[DONE] 004 - Quantile Prediction with PnL-based Gate'
description: "Quantile 예측 기반 선택적 트레이딩. Pinball Loss로 q10/q50/q90 예측. PnL soft label로 Gate 학습. TP/SL 자동 설정."
---

# 004 - Quantile Prediction with PnL-based Gate
{:.no_toc}

## 목차
{:.no_toc}

1. TOC
{:toc}

---

| 상태 | 생성일 | 수정일 |
|------|--------|--------|
| completed | 2025-12-18 | 2025-12-26 |

---

## Summary

min/max/close 각각을 q10, q50, q90 quantile로 예측하고, 이 출력을 Long/Short Gate의 입력으로 사용하는 직렬 구조. Gate는 PnL 기반 soft label로 학습하여 리스크 대비 수익률을 직접 반영.

### Current Model Structure
```
LSTM → Shared Dense → {long_gate, short_gate}
```

### Target Structure (직렬)
```
LSTM → Shared Dense → Quantile (9개) → {long_gate, short_gate}
                           ↓
                    (Quantile Loss 동시 적용)
```

### Output
- **quantile_output**: 9개
  - min: q10, q50, q90
  - max: q10, q50, q90
  - close: q10, q50, q90
- **long_gate**: 1개 (sigmoid)
- **short_gate**: 1개 (sigmoid)

## Motivation

1. **명시적 Risk/Reward 학습**: Gate가 quantile 예측값을 직접 보고 결정
2. **End-to-end 최적화**: Quantile 예측이 Gate 성능 향상에 직접 기여
3. **PnL 기반 라벨**: 이진분류(0/1) 대신 실제 수익률 기반 soft label
4. **TP/SL 설정**: 추론 시 quantile 값으로 Take Profit / Stop Loss 설정

## Quantile Output 예시

```python
# 현재가: $100,000 (BTC)
# 6시간 후 예측 (% 변화율)

quantile_output = [
    # min (기간 내 최저가)
    -0.025,  # min_q10: -2.5% (10% 확률로 이보다 더 하락)
    -0.015,  # min_q50: -1.5% (중앙값)
    -0.005,  # min_q90: -0.5% (90% 확률로 이 이상 하락)

    # max (기간 내 최고가)
    +0.008,  # max_q10: +0.8% (10% 확률로 이보다 덜 상승)
    +0.018,  # max_q50: +1.8% (중앙값)
    +0.030,  # max_q90: +3.0% (90% 확률로 이 이하 상승)

    # close (종가)
    -0.010,  # close_q10: -1.0%
    +0.005,  # close_q50: +0.5%
    +0.020,  # close_q90: +2.0%
]

# 해석:
# - 90% 확률로 최대 상승폭은 +3.0% 이하
# - 90% 확률로 최대 하락폭은 -0.5% 이상 (즉, -2.5%까지 갈 확률 10%)
# - Long 진입 시 TP=+1.8%, SL=-2.5% (보수적)
```

## Implementation Plan

### Phase 1: PnL 계산 (비율 기반)

```python
FEE = 0.005  # 0.5% 수수료
DOMINANCE_RATIO = 2.0  # 한쪽이 2배 이상 우세해야 유의미

def compute_pnl(upside_pct, downside_pct, fee=FEE, dominance_ratio=DOMINANCE_RATIO):
    """
    비율 기반 PnL 계산

    - 한쪽이 다른 쪽의 k배 이상이어야 TP/SL 도달로 인정
    - 모호한 경우 수수료만 손해

    Args:
        upside_pct: (max - open) / open
        downside_pct: (open - min) / open
        fee: 거래 수수료 (0.5%)
        dominance_ratio: 우세 판정 비율 (2.0 = 2배 이상)
    """
    if upside_pct > downside_pct * dominance_ratio:
        # 상승 우세 → Long TP, Short SL
        long_pnl = upside_pct - fee
        short_pnl = -upside_pct - fee
    elif downside_pct > upside_pct * dominance_ratio:
        # 하락 우세 → Short TP, Long SL
        long_pnl = -downside_pct - fee
        short_pnl = downside_pct - fee
    else:
        # 모호한 상황 → TP/SL 미도달, 수수료만 손해
        long_pnl = -fee
        short_pnl = -fee

    return long_pnl, short_pnl
```

### Phase 2: Soft Label 생성

```python
def compute_gate_labels(upside_pct, downside_pct, fee=FEE,
                        dominance_ratio=DOMINANCE_RATIO, temperature=2.0):
    """
    PnL 기반 soft label 생성

    이진분류(0/1) 대신 실제 PnL을 sigmoid로 변환하여
    리스크 대비 수익률에 비례하는 연속값 라벨 생성
    """
    long_pnl, short_pnl = compute_pnl(upside_pct, downside_pct, fee, dominance_ratio)

    # PnL을 sigmoid로 0~1 변환
    # *100: % 단위를 스케일링
    long_gate_y = 1 / (1 + np.exp(-long_pnl * 100 / temperature))
    short_gate_y = 1 / (1 + np.exp(-short_pnl * 100 / temperature))

    return long_gate_y, short_gate_y
```

### Label 예시

| upside | downside | 판정 | long_pnl | short_pnl | long_label | short_label |
|--------|----------|------|----------|-----------|------------|-------------|
| 3.0% | 1.0% | Long TP (3>1×2) | +2.5% | -3.5% | 0.78 | 0.15 |
| 1.0% | 3.0% | Short TP (3>1×2) | -3.5% | +2.5% | 0.15 | 0.78 |
| 2.0% | 1.5% | 미도달 (2<1.5×2) | -0.5% | -0.5% | 0.44 | 0.44 |
| 1.0% | 1.0% | 미도달 (동일) | -0.5% | -0.5% | 0.44 | 0.44 |
| 0.5% | 0.5% | 미도달 | -0.5% | -0.5% | 0.44 | 0.44 |

### Phase 3: Quantile Loss Function

```python
def quantile_loss(quantile: float):
    """
    Pinball Loss for quantile regression.
    """
    def loss(y_true, y_pred):
        error = y_true - y_pred
        return tf.reduce_mean(
            tf.maximum(quantile * error, (quantile - 1) * error)
        )
    return loss

def combined_quantile_loss(y_true, y_pred):
    """
    y_true: [min, max, close] - 3개
    y_pred: [min_q10, min_q50, min_q90, max_q10, ...] - 9개
    """
    quantiles = [0.1, 0.5, 0.9]
    total_loss = 0.0

    for i in range(3):  # min, max, close
        y_true_target = y_true[:, i:i+1]
        for j, q in enumerate(quantiles):
            y_pred_q = y_pred[:, i*3 + j:i*3 + j + 1]
            total_loss += quantile_loss(q)(y_true_target, y_pred_q)

    return total_loss / 9
```

### Phase 4: Model Architecture (직렬 구조)

```python
# LSTM → Shared Dense (기존)
shared_dense = Dense(64, activation='relu')(lstm_output)

# Quantile Head (9개 출력) - 중간 출력이자 Gate 입력
quantile_output = Dense(9, activation='linear', name='quantile_output')(shared_dense)

# Gate 입력: Shared Dense + Quantile 결합
gate_input = Concatenate()([shared_dense, quantile_output])

# Long/Short Gate - PnL 기반 soft label로 학습
long_gate = Dense(1, activation='sigmoid', name='long_gate')(gate_input)
short_gate = Dense(1, activation='sigmoid', name='short_gate')(gate_input)

# Model
model = Model(
    inputs=input_layer,
    outputs=[quantile_output, long_gate, short_gate]
)
```

### Phase 5: Loss 통합

```python
losses = {
    'quantile_output': combined_quantile_loss,
    'long_gate': 'binary_crossentropy',  # soft label과 호환
    'short_gate': 'binary_crossentropy',
}

loss_weights = {
    'quantile_output': LAMBDA_QUANTILE,
    'long_gate': LAMBDA_LONG_GATE,
    'short_gate': LAMBDA_SHORT_GATE,
}
```

### Phase 6: Gate Loss Warmup (선택적)

```python
class GateWarmupCallback(tf.keras.callbacks.Callback):
    def __init__(self, warmup_epochs=5):
        self.warmup_epochs = warmup_epochs

    def on_epoch_begin(self, epoch, logs=None):
        if epoch < self.warmup_epochs:
            self.model.loss_weights['long_gate'] = 0.0
            self.model.loss_weights['short_gate'] = 0.0
        else:
            self.model.loss_weights['long_gate'] = LAMBDA_LONG_GATE
            self.model.loss_weights['short_gate'] = LAMBDA_SHORT_GATE
```

### Phase 7: Evaluation Metrics

#### Quantile Calibration
```python
def quantile_calibration(y_true, y_pred_quantiles, quantiles=[0.1, 0.5, 0.9]):
    calibration = {}
    for i, q in enumerate(quantiles):
        coverage = np.mean(y_true <= y_pred_quantiles[:, i])
        calibration[f'q{int(q*100)}'] = coverage
        calibration[f'q{int(q*100)}_error'] = abs(coverage - q)
    return calibration
```

#### Gate Performance (PnL 기반)
```python
def evaluate_gate_pnl(predictions, actuals, threshold=0.5):
    """
    Gate 신호 발생 시 실제 PnL 계산
    """
    long_signals = predictions['long_gate'] > threshold
    short_signals = predictions['short_gate'] > threshold

    long_pnls = actuals['long_pnl'][long_signals]
    short_pnls = actuals['short_pnl'][short_signals]

    return {
        'long_avg_pnl': np.mean(long_pnls),
        'long_hit_rate': np.mean(long_pnls > 0),
        'short_avg_pnl': np.mean(short_pnls),
        'short_hit_rate': np.mean(short_pnls > 0),
    }
```

### Phase 8: 추론 시 TP/SL 설정

```python
def get_trade_decision(quantile_pred, long_gate_pred, short_gate_pred, threshold=0.5):
    """
    quantile_pred: [min_q10, min_q50, min_q90, max_q10, max_q50, max_q90, ...]
    """
    min_q10, min_q50, min_q90 = quantile_pred[0:3]
    max_q10, max_q50, max_q90 = quantile_pred[3:6]

    if long_gate_pred > threshold:
        return {
            'action': 'LONG',
            'tp': max_q50,      # 중앙값 기대 상승
            'sl': min_q90,      # 보수적 하락 하한
            'confidence': long_gate_pred,
        }
    elif short_gate_pred > threshold:
        return {
            'action': 'SHORT',
            'tp': min_q50,      # 중앙값 기대 하락
            'sl': max_q90,      # 보수적 상승 상한
            'confidence': short_gate_pred,
        }
    else:
        return {'action': 'NO_TRADE'}
```

## Configuration

```python
# PnL 계산
FEE = 0.005  # 0.5% 수수료
DOMINANCE_RATIO = 2.0  # 2배 이상 우세해야 TP/SL 인정

# Soft label
LABEL_TEMPERATURE = 2.0  # sigmoid 민감도

# Quantile settings
QUANTILES = [0.1, 0.5, 0.9]
OUTPUT_NAMES = ['min', 'max', 'close']

# Loss weights
LAMBDA_QUANTILE = 1.0
LAMBDA_LONG_GATE = 1.0
LAMBDA_SHORT_GATE = 1.0

# Gate warmup (선택적)
GATE_WARMUP_EPOCHS = 5
```

## Success Criteria

- [ ] Quantile Calibration Error < 0.05 for all quantiles
- [ ] No quantile crossing (q10 <= q50 <= q90)
- [ ] Long/Short Gate: threshold=0.6 이상에서 avg_pnl > 0
- [ ] Gate 신호 시 hit_rate > 55%
- [ ] TP/SL 기반 백테스트에서 양의 기대수익

## Files to Modify

- `src/prediction/prediction_model.py`
  - `_build_model()`: 직렬 구조로 변경 (Quantile → Gate)
  - `_get_loss_functions()`: quantile loss 추가
  - `parse_training_features()`: PnL 기반 soft label 생성
  - `evaluate()`: quantile calibration + PnL 기반 평가

## Dependencies

- [003-3-long-short-gate-separation](003-3-long-short-gate-separation.md) 완료 필수 (Long/Short Gate 구조)

## Estimated Scope

- PnL 계산 + soft label: ~40 lines
- Quantile loss function: ~30 lines
- Model 구조 변경: ~40 lines
- Label 처리: ~30 lines
- Evaluation metrics: ~60 lines
- **Total: ~200 lines**

## Notes

### 기존 대비 변경점
1. **라벨**: 이진(0/1) → PnL 기반 soft label (0~1 연속값)
2. **구조**: 병렬 → 직렬 (Quantile → Gate)
3. **평가**: accuracy → avg_pnl, hit_rate

### 학습 전략
1. **Option A**: 동시 학습 (Quantile + Gate 함께)
2. **Option B**: Gate warmup (Quantile 먼저 5 epoch → Gate 추가)
3. **Option C**: Pre-training (Quantile 완전 학습 → Gate fine-tuning)

### 향후 확장
- Conformalized Quantile Regression: calibration 보장
- Position sizing: confidence 기반 포지션 크기 조절
- Risk-adjusted metrics: Sharpe, MDD 등

## Related Tickets

- [003-3-long-short-gate-separation](003-3-long-short-gate-separation.md) - 선행 작업 (필수)
- [005-backtesting-framework](005-backtesting-framework.md) - TP/SL 기반 백테스트 검증

---

## Implementation Results

### Changed Files
| File | Changes |
|------|---------|
| `src/prediction/prediction_model.py` | Complete refactor: added 9 quantile outputs (min/max/close × q10/q50/q90), serial structure (Shared Dense → Quantile → Gate), PnL-based soft labels, combined_quantile_loss (Pinball loss), get_trade_decision with TP/SL, quantile_calibration metrics |

### Key Implementation Details

**New Constants:**
```python
LAMBDA_QUANTILE = 1.0
PNL_FEE = 0.005              # 0.5% 수수료
PNL_DOMINANCE_RATIO = 2.0    # 2배 이상 우세해야 TP/SL 인정
LABEL_TEMPERATURE = 2.0      # soft label sigmoid 민감도
QUANTILES = [0.1, 0.5, 0.9]  # q10, q50, q90
NUM_QUANTILE_OUTPUTS = 9     # min/max/close × 3 quantiles
```

**New Functions:**
- `compute_pnl()`: Vectorized PnL calculation with dominance ratio
- `compute_gate_soft_labels()`: PnL-based soft labels (0~1 continuous)
- `quantile_loss()`: Pinball loss for single quantile
- `combined_quantile_loss()`: Combined loss for all 9 quantiles
- `get_trade_decision()`: Trade decision with TP/SL based on quantile predictions
- `quantile_calibration()`: Calibration metrics for each quantile

**Model Architecture Change:**
```
Before: LSTM → Shared Dense → {long_gate, short_gate}
After:  LSTM → Shared Dense → Quantile (9) → {long_gate, short_gate}
                                   ↓
                           Gate uses Shared Dense + Quantile as input
```

**Training Changes:**
- 3 outputs: `[quantile_output, long_gate, short_gate]`
- `use_soft_labels` parameter for binary vs PnL-based labels
- Gate loss supports BCE, Bootstrapped BCE, Self-paced BCE

**Evaluation Changes:**
- Added quantile calibration metrics (q10/q50/q90 coverage, error)
- Quantile crossing violations detection
- Predictions include `quantile_y` and `quantile_pred`

### Test Results
- Python syntax validation: PASSED
- Module import test: PASSED
- Ruff linting: PASSED (ignoring E402, I001 - existing issues)

### Lessons Learned / Issues
- Gate input uses `Concatenate([shared_dropout, quantile_output])` for serial structure
- Quantile targets use `[min_pct, max_pct, close_pct]` order (3 values per sample)
- Soft labels use sigmoid transformation of PnL with temperature scaling
- `use_soft_labels=False` for evaluation to get binary ground truth

### Follow-up
- [ ] Run actual training experiments with soft labels
- [ ] Tune threshold based on quantile calibration results
- [ ] Validate TP/SL based trade decisions in [005-backtesting-framework](005-backtesting-framework.md)

### Pull Request
https://github.com/minhopark1271/trading/pull/14

### Completed
2025-12-26

